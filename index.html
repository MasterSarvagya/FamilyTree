<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Family Tree</title>
	<style type="text/css">
		* {
			box-sizing: border-box;
			vertical-align: middle;
			outline: 0px;
		}

		body {
			margin: 0px;
			padding: 0px;
			overflow: hidden;
		}

		#canvas {
			width: 100%;
			height: 100%;
		}

		#center_button {
			position: absolute;
			width: 5vw;
			height: 5vw;
			top: 85vh;
			left: 92vw;
			background-color: blue;
			border: 0px;
			border-radius: 50px;
			color: white;
			cursor: pointer;
			transition: transform 0.5s;
		}
		#center_button:hover {
			transform: scale(1.2);
		}
	</style> 
</head>
<body>

	<button id="center_button"><img src="images/center.png" style="object-fit:contain;width:70%;" onclick="centerCanvas()"></button>
	<canvas id="canvas"></canvas>

	<script type="text/javascript">

		let canvas = document.getElementById("canvas")
		let ctx = canvas.getContext('2d')

		let cameraOffset = { x: window.innerWidth/2, y: window.innerHeight/2 }
		let cameraZoom = 1
		let MAX_ZOOM = 5
		let MIN_ZOOM = 0.1
		let SCROLL_SENSITIVITY = 0.0005

		function draw()
		{
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;

    // Translate to the canvas centre before zooming - so you'll always zoom on what you're looking directly at
			ctx.translate( window.innerWidth / 2, window.innerHeight / 2 );
			ctx.scale(cameraZoom, cameraZoom);
			ctx.translate( -window.innerWidth / 2 + cameraOffset.x, -window.innerHeight / 2 + cameraOffset.y );
			ctx.clearRect(0,0, window.innerWidth, window.innerHeight);

			// drawRect(-canvas.width/2,-canvas.height/2,canvas.width,canvas.height);

			drawCharacterCard(-canvas.width/2 + 25,-canvas.height/2 + 25,"F");
			drawCharacterCard(canvas.width/2 - 175,-canvas.height/2+ 25,"M");
			drawCharacterCard(-175,-canvas.height/2+ 25,"M","images/robot.png","Mr. Robot");
			drawCharacterCard(25,-canvas.height/2+ 25,"F","images/robot.png","Mrs. Robot");

			requestAnimationFrame( draw )
		}

// Gets the relevant location from a mouse or single touch event
		function getEventLocation(e)
		{
			if (e.touches && e.touches.length == 1)
			{
				return { x:e.touches[0].clientX, y: e.touches[0].clientY }
			}
			else if (e.clientX && e.clientY)
			{
				return { x: e.clientX, y: e.clientY }        
			}
		}

		function drawRect(x, y, width, height)
		{
			ctx.fillRect( x, y, width, height )
		}

		function drawText(text, x, y, size, font)
		{
			ctx.font = `${size}px ${font}`;
			ctx.fillText(text, x, y);
		}

		function drawCharacterCard(x,y,gender,img_src = "",name = "")
		{
			var img = new Image();

			if(gender == "M" || gender == "m"){
				ctx.strokeStyle = "blue";
				ctx.fillStyle = "#b7e2fc";
				img.src = "images/male.png";
			}
			
			else {
				ctx.strokeStyle = "pink";
				ctx.fillStyle = "#ffe6ee";
				img.src = "images/female.png";
			}

			if (img_src != "")
				img.src = img_src;


			ctx.beginPath();
			ctx.roundRect(x, y, 150, 200, [25]);
			ctx.fill();
			ctx.drawImage(img, x + 25, y + 10, 100, 100);			
			ctx.stroke();

			ctx.fillStyle = "white"
			drawText(name,x+(75 - ctx.measureText(name).width/2),y+150,20,"arial");
		}

		function centerCanvas() {
			cameraOffset = { x: window.innerWidth/2, y: window.innerHeight/2 };
			console.log("hello")
		}

		let isDragging = false
		let dragStart = { x: 0, y: 0 }

		function onPointerDown(e)
		{
			isDragging = true
			dragStart.x = getEventLocation(e).x/cameraZoom - cameraOffset.x
			dragStart.y = getEventLocation(e).y/cameraZoom - cameraOffset.y
		}

		function onPointerUp(e)
		{
			isDragging = false
			initialPinchDistance = null
			lastZoom = cameraZoom
		}

		function onPointerMove(e)
		{
			if (isDragging)
			{
				cameraOffset.x = getEventLocation(e).x/cameraZoom - dragStart.x
				cameraOffset.y = getEventLocation(e).y/cameraZoom - dragStart.y
			}
		}

		function handleTouch(e, singleTouchHandler)
		{
			if ( e.touches.length == 1 )
			{
				singleTouchHandler(e)
			}
			else if (e.type == "touchmove" && e.touches.length == 2)
			{
				isDragging = false
				handlePinch(e)
			}
		}

		let initialPinchDistance = null
		let lastZoom = cameraZoom

		function handlePinch(e)
		{
			e.preventDefault()

			let touch1 = { x: e.touches[0].clientX, y: e.touches[0].clientY }
			let touch2 = { x: e.touches[1].clientX, y: e.touches[1].clientY }

    // This is distance squared, but no need for an expensive sqrt as it's only used in ratio
			let currentDistance = (touch1.x - touch2.x)**2 + (touch1.y - touch2.y)**2

			if (initialPinchDistance == null)
			{
				initialPinchDistance = currentDistance
			}
			else
			{
				adjustZoom( null, currentDistance/initialPinchDistance )
			}
		}

		function adjustZoom(zoomAmount, zoomFactor)
		{
			if (!isDragging)
			{
				if (zoomAmount)
				{
					cameraZoom += zoomAmount
				}
				else if (zoomFactor)
				{
					console.log(zoomFactor)
					cameraZoom = zoomFactor*lastZoom
				}

				cameraZoom = Math.min( cameraZoom, MAX_ZOOM )
				cameraZoom = Math.max( cameraZoom, MIN_ZOOM )

				console.log(zoomAmount)
			}
		}

		canvas.addEventListener('mousedown', onPointerDown)
		canvas.addEventListener('touchstart', (e) => handleTouch(e, onPointerDown))
		canvas.addEventListener('mouseup', onPointerUp)
		canvas.addEventListener('touchend',  (e) => handleTouch(e, onPointerUp))
		canvas.addEventListener('mousemove', onPointerMove)
		canvas.addEventListener('touchmove', (e) => handleTouch(e, onPointerMove))
		canvas.addEventListener( 'wheel', (e) => adjustZoom(-e.deltaY*SCROLL_SENSITIVITY))

		draw()

	</script>
	
</body>
</html>